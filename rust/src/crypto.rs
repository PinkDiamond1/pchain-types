/*
 Copyright 2022 ParallelChain Lab

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

use std::convert::TryInto;
use rs_merkle::{Hasher, MerkleTree, algorithms::Sha256};
use crate::Serializable;

/// An Ed25519 signature. These are generated by external accounts to authorize transactions,
/// and by validators to create proposals and cast votes during consensus.
pub type Signature = [u8; 64];

/// An Ed25519 secret key. These are used to produce Ed25519 signatures. 
pub type SecretKey = [u8; 32];

/// PublicAddress is either:
/// - an Ed25519 public key representing an external account, or
/// - a contract address.
pub type PublicAddress = [u8; 32];

/// A SHA256 hash. Used as block and transaction hashes, as well as to form Merkle tries.
pub type Sha256Hash = [u8; 32];

// Computes the Merkle root hash of a vector of serializable data.
pub fn merkle_root<A: Clone + Into<B>, B: Serializable<B>  + borsh::BorshSerialize>(data: &Vec<A>) -> Sha256Hash {
    // TODO [Alice]: null hash really isn't all 0s. 
    if data.len() == 0 {
        return [0; 32]
    }

    let leaves: Vec<[u8; 32]> = data
        .iter()
        .map(|datum| sha256::<_, B>(datum).into())
        .collect();
    let merkle_tree = MerkleTree::<Sha256>::from_leaves(&leaves);
    merkle_tree.root().unwrap()
}

/// Compute a Merkle Proof of inclusion of the leaf identified by `leaf_hash` inside `data`.
/// # Return value
/// If successful, returns a three tuple consisting of: 
/// 1. Leaf hashes.
/// 2. Root hashes.
/// 3. Proof.
pub fn merkle_proof<A: Clone + Into<B>, B: Serializable<B> + borsh::BorshSerialize>(
    data: &Vec<A>,
    leaf_index: usize
) -> Result<(Vec<Sha256Hash>, Sha256Hash, Vec<u8>), LeafOutOfRangeError>  {
    // TODO [Alice]: null hash really isn't all 0s. 
    if data.len() == 0 {
        return Err(LeafOutOfRangeError);
    }

    let leaves: Vec<[u8; 32]> = data
        .iter()
        .map(|datum| sha256::<_, B>(datum).into())
        .collect();
    let merkle_tree = MerkleTree::<Sha256>::from_leaves(&leaves);

    Ok((leaves, merkle_tree.root().unwrap(), merkle_tree.proof(&[leaf_index]).to_bytes()))
}

pub struct LeafOutOfRangeError;

fn sha256<C: Clone + Into<D>, D: Serializable<D> + borsh::BorshSerialize>(datum: &C) -> Sha256Hash {
        // TODO [Alice]: remove clone.
        let d: D = datum.clone().into();
        Sha256::hash(&<D as Serializable<D>>::serialize(&d)).to_vec().try_into().unwrap()
}
